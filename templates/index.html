<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Remote Lab Control</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            min-height: 100vh;
            padding: 20px;
            color: #e0e0e0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(30, 30, 30, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            overflow: hidden;
            animation: fadeInUp 0.6s ease-out;
            border: 1px solid #404040;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .header {
            background: linear-gradient(135deg, #1e3a5f 0%, #2c5282 50%, #3b5998 100%);
            color: white;
            padding: 30px 40px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23ffffff' fill-opacity='0.05'%3E%3Ccircle cx='30' cy='30' r='4'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E") repeat;
            opacity: 0.3;
        }

        .header h1 {
            font-size: 2.8em;
            font-weight: 600;
            font-family: 'Trebuchet MS', 'Lucida Grande', 'Lucida Sans Unicode', Arial, sans-serif;
            letter-spacing: 2px;
            margin: 0;
            position: relative;
            z-index: 1;
            background: linear-gradient(135deg, #ffffff 0%, #e0e0e0 50%, #ffffff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow:
                0 1px 0 rgba(255,255,255,0.8),
                0 2px 0 rgba(255,255,255,0.6),
                0 3px 0 rgba(255,255,255,0.4),
                0 4px 0 rgba(255,255,255,0.2),
                0 5px 10px rgba(0,0,0,0.3),
                0 0 20px rgba(255,255,255,0.1);
            filter: drop-shadow(0 0 10px rgba(255,255,255,0.3));
        }

        .main-layout {
            display: flex;
            min-height: calc(100vh - 120px);
        }

        .left-panel {
            flex: 0 0 380px;
            background: #252525;
            border-right: 1px solid #404040;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .right-panel {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel-section {
            background: #2a2a2a;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
            border: 1px solid #404040;
        }

        .panel-section:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.2);
            border-color: #555;
        }

        .section-title {
            font-size: 1.3em;
            font-weight: 600;
            color: #e0e0e0;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-title::before {
            content: '';
            width: 4px;
            height: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 2px;
        }

        .refresh-icon {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            border-radius: 6px;
            transition: all 0.3s ease;
            color: #ffffff;
            margin-left: auto;
            position: relative;
        }

        .refresh-icon:hover {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
        }

        .refresh-icon:active {
            transform: scale(0.9);
        }

        .refresh-icon.spinning svg {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Device Selection */
        .device-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .device-item {
            padding: 15px 20px;
            border: 2px solid #555;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #333;
            position: relative;
            overflow: hidden;
        }

        .device-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .device-item:hover::before {
            left: 100%;
        }

        .device-item:hover {
            border-color: #667eea;
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .device-item.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.15) 0%, rgba(118, 75, 162, 0.15) 100%);
            transform: translateX(5px);
        }

        .device-item strong {
            display: block;
            color: #e0e0e0;
            font-size: 1.1em;
        }

        .device-item small {
            color: #b0b0b0;
            font-size: 0.9em;
        }

        /* Upload Area */
        .upload-area {
            border: 2px dashed #667eea;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.02) 0%, rgba(118, 75, 162, 0.02) 100%);
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.05) 0%, rgba(118, 75, 162, 0.05) 100%);
            transform: scale(1.01);
        }

        .upload-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin-top: 20px;
        }

        .file-label, .refresh-btn {
            flex: 1;
            max-width: 200px;
        }

        .file-input {
            display: none;
        }

        .file-label {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 1em;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .file-label svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        .file-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .file-label.reupload {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }

        .file-label.reupload:hover {
            box-shadow: 0 6px 20px rgba(40, 167, 69, 0.4);
        }

        .refresh-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .refresh-btn:hover {
            background: #5a6268;
            transform: scale(1.05);
        }

        /* Flash Button */
        .flash-btn {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            width: 100%;
            font-size: 1.1em;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
            margin-top: 20px;
        }

        .flash-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4);
        }

        .flash-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            box-shadow: none;
        }

        .flash-btn:disabled:hover {
            transform: none;
        }

        /* Video Section */
        .video-container {
            position: relative;
            background: #000;
            border-radius: 15px;
            overflow: hidden;
            aspect-ratio: 16/9;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }

        .video-container:hover {
            transform: scale(1.02);
            box-shadow: 0 12px 35px rgba(0,0,0,0.3);
        }

        .video-element {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .video-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #666;
            font-size: 1.2em;
            text-align: center;
            padding: 20px;
        }

        .video-placeholder::before {
            content: '';
            width: 4em;
            height: 4em;
            margin-bottom: 15px;
            opacity: 0.5;
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='currentColor'%3E%3Cpath d='M17,10.5V7A1,1 0 0,0 16,6H4A1,1 0 0,0 3,7V17A1,1 0 0,0 4,18H16A1,1 0 0,0 17,17V13.5L21,17.5V6.5L17,10.5Z'/%3E%3C/svg%3E") no-repeat center;
            background-size: contain;
        }

        .video-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .video-container:hover .video-overlay {
            opacity: 1;
            pointer-events: auto;
        }

        .video-btn {
            background: rgba(255,255,255,0.9);
            color: #333;
            border: none;
            padding: 15px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .video-btn:hover {
            background: white;
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .video-btn.active {
            background: #e74c3c;
            color: white;
        }

        /* Oscilloscope */
        .oscilloscope-container {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
        }

        .oscilloscope-canvas {
            width: 100%;
            height: 300px;
            background: #000;
            border-radius: 8px;
            display: block;
        }

        .oscilloscope-controls {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .oscilloscope-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .oscilloscope-btn:hover {
            background: #5a67d8;
            transform: scale(1.05);
        }

        .oscilloscope-btn.active {
            background: #e74c3c;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-label {
            font-size: 0.9em;
            color: #666;
            font-weight: 500;
        }

        .control-input {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.9em;
            width: 80px;
        }

        /* Serial Monitor */
        .serial-container {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
        }

        .serial-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .serial-input {
            flex: 1;
            min-width: 200px;
            padding: 10px 15px;
            border: 1px solid #444;
            border-radius: 8px;
            background: #2a2a2a;
            color: #e0e0e0;
            font-size: 0.9em;
        }

        .serial-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .serial-btn:hover {
            background: #218838;
            transform: scale(1.05);
        }

        .serial-btn.danger {
            background: #dc3545;
        }

        .serial-btn.danger:hover {
            background: #c82333;
        }

        .serial-terminal {
            background: #000;
            border-radius: 8px;
            padding: 15px;
            height: 250px;
            overflow-y: auto;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            font-size: 12px;
            line-height: 1.4;
            color: #e0e0e0;
            border: 1px solid #444;
        }

        .serial-line {
            margin-bottom: 5px;
            padding: 2px 0;
        }

        .serial-tx {
            color: #28a745;
        }

        .serial-rx {
            color: #17a2b8;
        }

        .serial-error {
            color: #dc3545;
        }

        /* Status and Messages */
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-offline {
            background: #6c757d;
        }

        .status-online {
            background: #28a745;
            box-shadow: 0 0 10px rgba(40, 167, 69, 0.5);
        }

        .status-error {
            background: #dc3545;
            box-shadow: 0 0 10px rgba(220, 53, 69, 0.5);
        }

        .file-info {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .upload-status {
            padding: 12px 20px;
            border-radius: 8px;
            margin-top: 15px;
            display: none;
            font-size: 0.95em;
            font-weight: 500;
        }

        .upload-success {
            background: linear-gradient(135deg, rgba(40, 167, 69, 0.1) 0%, rgba(32, 201, 151, 0.1) 100%);
            color: #155724;
            border: 1px solid rgba(40, 167, 69, 0.2);
        }

        .upload-error {
            background: linear-gradient(135deg, rgba(220, 53, 69, 0.1) 0%, rgba(255, 193, 7, 0.1) 100%);
            color: #721c24;
            border: 1px solid rgba(220, 53, 69, 0.2);
        }

        /* Terminal */
        .terminal {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 20px;
            height: 300px;
            overflow-y: auto;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            font-size: 13px;
            line-height: 1.4;
            border: 1px solid #333;
        }

        .terminal-header {
            color: #888;
            margin-bottom: 15px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .terminal-content {
            color: #e0e0e0;
        }

        .log-line {
            margin-bottom: 5px;
            padding: 2px 0;
        }

        .log-success {
            color: #28a745;
        }

        .log-error {
            color: #dc3545;
        }

        .log-info {
            color: #17a2b8;
        }

        .status-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .status-idle {
            background: #6c757d;
        }

        .status-working {
            background: #ffc107;
            animation: pulse 1s infinite;
        }

        .status-success {
            background: #28a745;
        }

        .status-error {
            background: #dc3545;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .main-layout {
                flex-direction: column;
            }

            .left-panel {
                flex: none;
                border-right: none;
                border-bottom: 1px solid #e9ecef;
            }

            .right-panel {
                padding: 20px;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .container {
                border-radius: 10px;
            }

            .header {
                padding: 20px;
            }

            .header h1 {
                font-size: 1.8em;
            }

            .left-panel, .right-panel {
                padding: 20px;
            }

            .panel-section {
                padding: 20px;
            }

            .video-overlay {
                flex-direction: column;
                gap: 15px;
            }

            .oscilloscope-controls, .serial-controls {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }

            .control-group {
                justify-content: space-between;
            }

            .serial-input {
                min-width: unset;
                width: 100%;
            }
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.5em;
            }

            .section-title {
                font-size: 1.1em;
            }

            .file-label, .flash-btn {
                padding: 12px 20px;
                font-size: 0.95em;
            }

            .video-btn {
                padding: 12px 20px;
                font-size: 0.9em;
            }

            .oscilloscope-canvas {
                height: 200px;
            }

            .serial-terminal, .terminal {
                height: 200px;
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Remote Lab Control</h1>
        </div>

        <div class="main-layout">
            <!-- Left Panel: Device Selection, Upload, Flash -->
            <div class="left-panel">
                <div class="panel-section">
                    <h2 class="section-title">
                        Select Device
                        <button class="refresh-icon" onclick="refreshDevices()" title="Refresh Devices">
                            <svg viewBox="0 0 24 24" width="18" height="18">
                                <path d="M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z"/>
                            </svg>
                        </button>
                    </h2>
                    <div id="devicesList" class="device-list">
                        <div class="device-item">Loading devices...</div>
                    </div>
                </div>

                <div class="panel-section">
                    <h2 class="section-title">Upload Firmware</h2>
                    <div class="upload-area">
                        <input type="file" id="fileInput" class="file-input" accept=".hex,.bin" onchange="handleFileUpload(event)">
                        <label for="fileInput" class="file-label">
                            <svg viewBox="0 0 24 24" width="16" height="16">
                                <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
                            </svg>
                            Choose File
                        </label>
                    </div>

                    <div id="uploadStatus" class="upload-status"></div>

                    <div id="currentFirmware" class="file-info" style="display: none;">
                        <strong>File:</strong> <span id="firmwareName"></span><br>
                        <strong>Size:</strong> <span id="firmwareSize"></span>
                    </div>

                    <button id="flashBtn" class="flash-btn" onclick="startFlash()" disabled>
                        Flash Firmware
                    </button>
                </div>

                <div class="panel-section">
                    <h2 class="section-title">Terminal Output</h2>
                    <div class="terminal">
                        <div class="terminal-header">
                            <span class="status-dot status-idle" id="statusDot"></span>
                            <span id="terminalStatus">Idle</span>
                        </div>
                        <div id="terminalContent" class="terminal-content"></div>
                    </div>
                </div>
            </div>

            <!-- Right Panel: Lab Setup -->
            <div class="right-panel">
                <!-- Video Section -->
                <div class="panel-section">
                    <h2 class="section-title">Video Stream</h2>
                    <div class="video-container">
                        <div id="videoPlaceholder" class="video-placeholder">
                            Video Stream Offline<br>
                            <small>Hover to start streaming</small>
                        </div>
                        <img id="videoElement" class="video-element" alt="Live Video Stream" style="display: none;">
                        <div class="video-overlay">
                            <button id="videoBtn" class="video-btn" onclick="toggleVideo()" title="Play/Pause Video">
                                <svg id="videoIcon" viewBox="0 0 24 24" width="24" height="24">
                                    <path d="M8,5.14V19.14L19,12.14L8,5.14Z"/>
                                </svg>
                            </button>
                            <button id="audioBtn" class="video-btn" onclick="toggleAudio()" title="Mute/Unmute Audio">
                                <svg id="audioIcon" viewBox="0 0 24 24" width="24" height="24">
                                    <path d="M3,9V15H7L12,20V4L7,9H3Z"/>
                                    <path d="M16.5,12C16.5,10.23 15.48,8.71 14,7.97V10.18L16.45,12.63C16.48,12.43 16.5,12.22 16.5,12M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.85 14,18.71V20.77C18.01,19.86 21,16.28 21,12C21,7.72 18.01,4.14 14,3.23Z"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div id="streamStatus" class="upload-status" style="display: none;"></div>
                </div>


                <!-- Logic Analyzer Section -->
                <div class="panel-section">
                    <h2 class="section-title">Logic Analyzer</h2>
                    <div class="oscilloscope-container">
                        <canvas id="logicAnalyzerCanvas" class="oscilloscope-canvas"></canvas>
                        <div class="oscilloscope-controls">
                            <button id="logicAnalyzerBtn" class="oscilloscope-btn" onclick="toggleLogicAnalyzer()">
                                Start Logic Analyzer
                            </button>
                            <button id="logicPauseBtn" class="oscilloscope-btn" onclick="toggleLogicPause()" style="display: none;">
                                Pause
                            </button>
                            <div class="control-group">
                                <span class="control-label">Channel:</span>
                                <select id="channelSelect" class="control-input">
                                    <option value="both">Both</option>
                                    <option value="ch1">Channel 1</option>
                                    <option value="ch2">Channel 2</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <span class="control-label">Timebase:</span>
                                <input type="range" id="logicTimebaseInput" class="control-input" min="0.0005" max="0.05" step="0.0005" value="0.001">
                            </div>
                            <div class="control-group">
                                <span class="control-label">Amplitude:</span>
                                <input type="range" id="logicAmplitudeInput" class="control-input" min="0.5" max="2.0" step="0.1" value="1.0">
                            </div>

                            <button class="oscilloscope-btn" onclick="clearLogicAnalyzer()">Clear</button>
                        </div>
                    </div>
                </div>

                <!-- Serial Monitor Section -->
                <div class="panel-section">
                    <h2 class="section-title">Serial Monitor</h2>
                    <div class="serial-container">
                        <div class="serial-controls">
                            <select id="serialPort" class="serial-input">
                                <option value="">Select Port</option>
                            </select>
                            <input type="number" id="baudRate" class="serial-input" value="9600" min="300" max="115200" style="width: 100px;">
                            <button id="connectSerialBtn" class="serial-btn" onclick="toggleSerialMonitor()">
                                Connect
                            </button>
                            <button id="disconnectSerialBtn" class="serial-btn danger" onclick="disconnectSerial()" style="display: none;">
                                Disconnect
                            </button>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span class="status-indicator status-offline" id="serialStatus"></span>
                                <span id="serialStatusText">Disconnected</span>
                            </div>
                            <button class="serial-btn" onclick="clearSerialTerminal()" style="background: #6c757d;">Clear</button>
                        </div>

                        <div class="serial-controls">
                            <input type="text" id="serialInput" class="serial-input" placeholder="Enter command to send..." onkeypress="handleSerialKeyPress(event)">
                            <button class="serial-btn" onclick="sendSerialData()">Send</button>
                        </div>

                        <div id="serialTerminal" class="serial-terminal"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        let selectedDevice = null;
        let currentFirmware = null;
        let isUploading = false;
        let socket = null;
        let videoActive = false;
        let audioActive = false;
        let serialConnected = false;
        let audioContext = null;
        let audioBufferQueue = [];
        let isPlayingAudio = false;
        let lastVideoFrameTime = 0;
        let audioSyncOffset = 0;
        let audioPlaybackInterval = null;
        const MAX_AUDIO_BUFFER_SIZE = 8;

        // Logic Analyzer variables - simplified for differential signals
        let logicAnalyzerActive = false;
        let logicAnalyzerCanvas = null;
        let logicAnalyzerCtx = null;
        let logicAnalyzerData = {
            ch1_data: [], ch2_data: [], timestamps: [],
            ch1_frequency: 0, ch1_duty_cycle: 0,
            ch2_frequency: 0, ch2_duty_cycle: 0
        };
        let logicChannelMode = 'both';
        let logicTimebase = 0.001;
        let logicAmplitudeScale = 1.0;
        let logicAnimationId = null;
        let logicAnimationPaused = false;

        // Cooldown variables for buttons
        let lastSerialToggleTime = 0;
        let lastVideoToggleTime = 0;
        let lastAudioToggleTime = 0;
        const COOLDOWN_TIME = 2000; // 2 seconds cooldown

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            refreshDevices();
            refreshSerialPorts();
            setInterval(updateTerminal, 1000);
            document.getElementById('fileInput').addEventListener('change', handleFileUpload);
            initializeSocket();
            initializeLogicAnalyzer();
        });

        function initializeSocket() {
            console.log('Initializing socket connection...');
            socket = io();

            socket.on('connect', function() {
                console.log('Socket connected successfully, ID:', socket.id);
            });

            socket.on('disconnect', function() {
                console.log('Socket disconnected');
            });

            socket.on('connect_error', function(error) {
                console.error('Socket connection error:', error);
            });

            socket.on('connect_timeout', function(timeout) {
                console.error('Socket connection timeout:', timeout);
            });

            socket.on('video_frame', function(data) {
                const currentTime = Date.now();
                lastVideoFrameTime = currentTime;

                const videoElement = document.getElementById('videoElement');
                if (videoElement) {
                    videoElement.src = 'data:image/jpeg;base64,' + data.frame;
                }

                // Audio is now handled independently of video
                // No need to trigger playback on video frames
            });

            socket.on('audio_data', function(data) {
                // Handle audio data independently of video
                handleAudioData(data);
            });

            socket.on('serial_data', function(data) {
                addToSerialTerminal(data.data, 'rx');
            });

            socket.on('serial_sent', function(data) {
                addToSerialTerminal(data.data, 'tx');
            });

            socket.on('streaming_status', function(data) {
                handleStreamingStatus(data);
            });

            socket.on('serial_status', function(data) {
                handleSerialStatus(data);
            });

            socket.on('logic_analyzer_data', function(data) {
                console.log('Received logic_analyzer_data event:', data);
                handleLogicAnalyzerData(data);
            });

            socket.on('test_event', function(data) {
                console.log('Received test event:', data);
                alert('Test event received: ' + JSON.stringify(data));
            });

            // Listen for all events to debug
            socket.onAny(function(event, ...args) {
                console.log('Received event:', event, args);
            });

            // Test if socket is connected
            setTimeout(function() {
                console.log('Socket connected status:', socket.connected);
                console.log('Socket ID:', socket.id);
            }, 1000);
        }

        function refreshDevices() {
            // Add spinning animation
            const refreshIcon = document.querySelector('.refresh-icon');
            if (refreshIcon) {
                refreshIcon.classList.add('spinning');
            }

            fetch('/devices')
                .then(response => response.json())
                .then(data => {
                    const devicesList = document.getElementById('devicesList');
                    if (data.devices.length === 0) {
                        devicesList.innerHTML = '<div class="device-item">No devices detected</div>';
                        document.getElementById('flashBtn').disabled = true;
                    } else {
                        devicesList.innerHTML = '';
                        data.devices.forEach(device => {
                            const deviceItem = document.createElement('div');
                            deviceItem.className = 'device-item';
                            deviceItem.onclick = () => selectDevice(deviceItem, device);
                            deviceItem.innerHTML = `<strong>${device[2]}</strong><br><small>${device[1]}</small>`;
                            devicesList.appendChild(deviceItem);
                        });
                    }
                })
                .catch(error => {
                    console.error('Error fetching devices:', error);
                    document.getElementById('devicesList').innerHTML = '<div class="device-item">Error loading devices</div>';
                })
                .finally(() => {
                    // Remove spinning animation after a short delay
                    setTimeout(() => {
                        if (refreshIcon) {
                            refreshIcon.classList.remove('spinning');
                        }
                    }, 500);
                });
        }

        function refreshSerialPorts() {
            fetch('/devices')
                .then(response => response.json())
                .then(data => {
                    const serialPortSelect = document.getElementById('serialPort');
                    serialPortSelect.innerHTML = '<option value="">Select Port</option>';

                    data.devices.forEach(device => {
                        if (device[1] !== 'N/A') {  // Skip USBASP with N/A port
                            const option = document.createElement('option');
                            option.value = device[1];
                            option.textContent = `${device[2]} (${device[1]})`;
                            serialPortSelect.appendChild(option);
                        }
                    });
                })
                .catch(error => {
                    console.error('Error fetching serial ports:', error);
                });
        }

        function selectDevice(item, device) {
            // Remove previous selection
            document.querySelectorAll('.device-item').forEach(i => i.classList.remove('selected'));
            // Add selection to clicked item
            item.classList.add('selected');
            selectedDevice = device;
            document.getElementById('flashBtn').disabled = !currentFirmware;
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const formData = new FormData();
            formData.append('file', file);

            fetch('/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    showUploadStatus(data.error, 'error');
                } else {
                    showUploadStatus('File uploaded successfully!', 'success');
                    currentFirmware = data.filename;
                    document.getElementById('firmwareName').textContent = data.filename;
                    document.getElementById('firmwareSize').textContent = formatFileSize(file.size);
                    document.getElementById('currentFirmware').style.display = 'block';
                    document.getElementById('flashBtn').disabled = !selectedDevice;

                    // Change button to re-upload mode
                    const fileLabel = document.querySelector('.file-label');
                    const textNode = fileLabel.lastChild;
                    if (textNode.nodeType === Node.TEXT_NODE) {
                        textNode.textContent = 'Re-upload File';
                    }
                    fileLabel.classList.add('reupload');

                    // Clear the file input so the same file can be selected again
                    event.target.value = '';
                }
            })
            .catch(error => {
                console.error('Upload error:', error);
                showUploadStatus('Upload failed!', 'error');
            });
        }

        function showUploadStatus(message, type) {
            const statusDiv = document.getElementById('uploadStatus');
            statusDiv.textContent = message;
            statusDiv.className = `upload-status upload-${type}`;
            statusDiv.style.display = 'block';
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 3000);
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function startFlash() {
            if (!selectedDevice || !currentFirmware || isUploading) return;

            isUploading = true;
            document.getElementById('flashBtn').disabled = true;
            document.getElementById('flashBtn').textContent = 'Flashing...';
            document.getElementById('statusDot').className = 'status-dot status-working';
            document.getElementById('terminalStatus').textContent = 'Flashing';

            const formData = new FormData();
            formData.append('device_type', selectedDevice[0]);
            formData.append('port', selectedDevice[1]);
            formData.append('chip_type', selectedDevice[3]);

            fetch('/flash', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('Error: ' + data.error);
                    resetUploadState();
                } else {
                    // Wait for terminal updates
                    setTimeout(() => {
                        isUploading = false;
                    }, 1000);
                }
            })
            .catch(error => {
                console.error('Flash error:', error);
                alert('Flash failed!');
                resetUploadState();
            });
        }

        function resetUploadState() {
            isUploading = false;
            document.getElementById('flashBtn').disabled = !selectedDevice || !currentFirmware;
            document.getElementById('flashBtn').textContent = 'Flash Firmware';
            document.getElementById('statusDot').className = 'status-dot status-idle';
            document.getElementById('terminalStatus').textContent = 'Idle';
        }

        function updateTerminal() {
            fetch('/terminal')
                .then(response => response.json())
                .then(data => {
                    const terminalContent = document.getElementById('terminalContent');
                    terminalContent.innerHTML = '';

                    if (data.output.length > 0) {
                        data.output.forEach(line => {
                            const logLine = document.createElement('div');
                            logLine.className = 'log-line';

                            if (line.includes('✅')) {
                                logLine.className += ' log-success';
                            } else if (line.includes('❌') || line.includes('Error')) {
                                logLine.className += ' log-error';
                            } else if (line.includes('Executing:')) {
                                logLine.className += ' log-info';
                            }

                            logLine.textContent = line;
                            terminalContent.appendChild(logLine);
                        });

                        // Scroll to bottom
                        terminalContent.scrollTop = terminalContent.scrollHeight;
                    }

                    if (data.in_progress) {
                        document.getElementById('statusDot').className = 'status-dot status-working';
                        document.getElementById('terminalStatus').textContent = 'Flashing';
                    } else if (data.output.length > 0) {
                        const lastLine = data.output[data.output.length - 1];
                        if (lastLine.includes('✅')) {
                            document.getElementById('statusDot').className = 'status-dot status-success';
                            document.getElementById('terminalStatus').textContent = 'Success';
                        } else if (lastLine.includes('❌')) {
                            document.getElementById('statusDot').className = 'status-dot status-error';
                            document.getElementById('terminalStatus').textContent = 'Error';
                        } else {
                            document.getElementById('statusDot').className = 'status-dot status-idle';
                            document.getElementById('terminalStatus').textContent = 'Idle';
                        }
                        resetUploadState();
                    }
                })
                .catch(error => {
                    console.error('Terminal update error:', error);
                });
        }

        // Video Streaming Functions
        function toggleVideo() {
            const now = Date.now();
            if (now - lastVideoToggleTime < COOLDOWN_TIME) {
                return; // Still in cooldown
            }
            lastVideoToggleTime = now;

            const videoBtn = document.getElementById('videoBtn');
            const videoIcon = document.getElementById('videoIcon');

            if (videoActive) {
                // Stop video - show play icon
                socket.emit('start_streaming', { video: false, audio: audioActive });
                videoIcon.innerHTML = '<path d="M8,5.14V19.14L19,12.14L8,5.14Z"/>'; // Play icon
                videoBtn.classList.remove('active');
                videoActive = false;
                const videoContainer = document.getElementById('videoContainer');
                if (videoContainer) {
                    videoContainer.style.display = 'none';
                }
            } else {
                // Start video - show pause icon
                socket.emit('start_streaming', { video: true, audio: audioActive });
                videoIcon.innerHTML = '<path d="M6,4V20H10V4H6M14,4V20H18V4H14Z"/>'; // Pause icon
                videoBtn.classList.add('active');
                videoActive = true;
            }
        }

        function toggleAudio() {
            const now = Date.now();
            if (now - lastAudioToggleTime < COOLDOWN_TIME) {
                return; // Still in cooldown
            }
            lastAudioToggleTime = now;

            const audioBtn = document.getElementById('audioBtn');
            const audioIcon = document.getElementById('audioIcon');

            if (audioActive) {
                // Mute audio - show mute icon
                socket.emit('start_streaming', { video: videoActive, audio: false });
                audioIcon.innerHTML = '<path d="M3.63,3.63a.996.996,0,0,0,0,1.41L7.29,8.7L7,9H4A1,1,0,0,0,3,10V14A1,1,0,0,0,4,15H6L10,19V12.41L13.23,15.64A1,1,0,0,0,14,15.29A1,1,0,0,0,14.29,14L12.12,11.83L14.2,9.75A1,1,0,0,0,14.41,8.34A1,1,0,0,0,13,8.59L10.29,11.29L8.34,9.34L10.05,7.63A1,1,0,0,0,10.29,6.22A1,1,0,0,0,9,6.59L7.08,8.51L3.63,5.06A.996.996,0,0,0,3.63,3.63Z"/><path d="M19,12C19,12.82,18.82,13.59,18.59,14.3L17.17,12.88C17.06,12.63,17,12.32,17,12A3,3,0,0,1,20,9V7A1,1,0,0,0,19,6V8.18A5,5,0,0,0,15,8.18V6A1,1,0,0,0,14,7V9A5,5,0,0,0,19,14Z"/>'; // Mute icon
                audioBtn.classList.remove('active');
                audioActive = false;
                // Clear audio buffer when stopping
                audioBufferQueue = [];
                audioDataQueue = [];
                isPlayingAudio = false;
                // Cleanup audio processor
                cleanupAudioProcessor();
                // Stop independent audio playback
                stopIndependentAudioPlayback();
            } else {
                // Unmute audio - show speaker icon
                socket.emit('start_streaming', { video: videoActive, audio: true });
                audioIcon.innerHTML = '<path d="M3,9V15H7L12,20V4L7,9H3Z"/><path d="M16.5,12C16.5,10.23 15.48,8.71 14,7.97V10.18L16.45,12.63C16.48,12.43 16.5,12.22 16.5,12M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.85 14,18.71V20.77C18.01,19.86 21,16.28 21,12C21,7.72 18.01,4.14 14,3.23Z"/>'; // Speaker icon
                audioBtn.classList.add('active');
                audioActive = true;
                // Initialize audio processor for clean playback
                initializeAudioProcessor();
                // Start independent audio playback
                startIndependentAudioPlayback();
            }
        }

        function handleStreamingStatus(data) {
            const statusDiv = document.getElementById('streamStatus');

            if (data.status === 'started') {
                if (data.type === 'video') {
                    showVideoElement();
                }
                statusDiv.textContent = `${data.type} streaming started`;
                statusDiv.className = 'upload-status upload-success';
            } else if (data.status === 'stopped') {
                statusDiv.textContent = 'Streaming stopped';
                statusDiv.className = 'upload-status upload-success';
                // Reset all streaming states when stopped
                resetStreamingButtons();
            } else if (data.status === 'error') {
                statusDiv.textContent = `Streaming error: ${data.message}`;
                statusDiv.className = 'upload-status upload-error';
                // Only reset the specific stream that failed, not all streams
                if (data.type === 'video') {
                    videoActive = false;
                    const videoBtn = document.getElementById('videoBtn');
                    const videoIcon = document.getElementById('videoIcon');
                    if (videoBtn) {
                        if (videoIcon) {
                            videoIcon.innerHTML = '<path d="M8,5.14V19.14L19,12.14L8,5.14Z"/>'; // Play icon
                        }
                        videoBtn.classList.remove('active');
                    }
                    hideVideoElement();
                } else if (data.type === 'audio') {
                    audioActive = false;
                    const audioBtn = document.getElementById('audioBtn');
                    const audioIcon = document.getElementById('audioIcon');
                    if (audioBtn) {
                        if (audioIcon) {
                            audioIcon.innerHTML = '<path d="M3,9V15H7L12,20V4L7,9H3Z"/><path d="M16.5,12C16.5,10.23 15.48,8.71 14,7.97V10.18L16.45,12.63C16.48,12.43 16.5,12.22 16.5,12M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.85 14,18.71V20.77C18.01,19.86 21,16.28 21,12C21,7.72 18.01,4.14 14,3.23Z"/>'; // Speaker icon
                        }
                        audioBtn.classList.remove('active');
                    }
                    // Cleanup audio processor on error
                    cleanupAudioProcessor();
                    // Stop independent audio playback on error
                    stopIndependentAudioPlayback();
                }
            }

            statusDiv.style.display = 'block';
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 3000);
        }

        function resetStreamingButtons() {
            const videoBtn = document.getElementById('videoBtn');
            const audioBtn = document.getElementById('audioBtn');
            const videoIcon = document.getElementById('videoIcon');
            const audioIcon = document.getElementById('audioIcon');

            // Reset video button to play icon
            if (videoIcon) {
                videoIcon.innerHTML = '<path d="M8,5.14V19.14L19,12.14L8,5.14Z"/>'; // Play icon
            }
            videoBtn.classList.remove('active');

            // Reset audio button to speaker icon
            if (audioIcon) {
                audioIcon.innerHTML = '<path d="M3,9V15H7L12,20V4L7,9H3Z"/><path d="M16.5,12C16.5,10.23 15.48,8.71 14,7.97V10.18L16.45,12.63C16.48,12.43 16.5,12.22 16.5,12M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.85 14,18.71V20.77C18.01,19.86 21,16.28 21,12C21,7.72 18.01,4.14 14,3.23Z"/>'; // Speaker icon
            }
            audioBtn.classList.remove('active');

            videoActive = false;
            audioActive = false;

            // Clear audio buffer when stopping
            audioBufferQueue = [];
            audioDataQueue = [];
            isPlayingAudio = false;

            // Cleanup audio processor
            cleanupAudioProcessor();

            // Stop independent audio playback
            stopIndependentAudioPlayback();

            hideVideoElement();
        }

        function showVideoElement() {
            const videoElement = document.getElementById('videoElement');
            const videoPlaceholder = document.getElementById('videoPlaceholder');
            if (videoElement) {
                videoElement.style.display = 'block';
            }
            if (videoPlaceholder) {
                videoPlaceholder.style.display = 'none';
            }
        }

        function hideVideoElement() {
            const videoElement = document.getElementById('videoElement');
            const videoPlaceholder = document.getElementById('videoPlaceholder');
            if (videoElement) {
                videoElement.style.display = 'none';
            }
            if (videoPlaceholder) {
                videoPlaceholder.style.display = 'flex';
            }
        }

        // Serial Monitor Functions
        function toggleSerialMonitor() {
            const now = Date.now();
            if (now - lastSerialToggleTime < COOLDOWN_TIME) {
                return; // Still in cooldown
            }
            lastSerialToggleTime = now;

            const port = document.getElementById('serialPort').value;
            const baudrate = document.getElementById('baudRate').value;

            if (!port) {
                alert('Please select a serial port');
                return;
            }

            if (serialConnected) {
                disconnectSerial();
            } else {
                socket.emit('start_serial_monitor', { port: port, baudrate: parseInt(baudrate) });
            }
        }

        function disconnectSerial() {
            socket.emit('stop_serial_monitor');
        }

        function sendSerialData() {
            const input = document.getElementById('serialInput');
            const data = input.value.trim();
            if (data && serialConnected) {
                socket.emit('send_serial_data', { data: data });
                input.value = '';
            }
        }

        function handleSerialKeyPress(event) {
            if (event.key === 'Enter') {
                sendSerialData();
            }
        }

        function clearSerialTerminal() {
            document.getElementById('serialTerminal').innerHTML = '';
        }

        function addToSerialTerminal(data, type) {
            const terminal = document.getElementById('serialTerminal');
            const line = document.createElement('div');
            line.className = `serial-line serial-${type}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${type.toUpperCase()}: ${data}`;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
        }

        function handleSerialStatus(data) {
            const statusIndicator = document.getElementById('serialStatus');
            const statusText = document.getElementById('serialStatusText');
            const connectBtn = document.getElementById('connectSerialBtn');
            const disconnectBtn = document.getElementById('disconnectSerialBtn');

            if (data.status === 'started') {
                serialConnected = true;
                statusIndicator.className = 'status-indicator status-online';
                statusText.textContent = `Connected (${data.port} @ ${data.baudrate} baud)`;
                connectBtn.style.display = 'none';
                disconnectBtn.style.display = 'inline-block';
            } else if (data.status === 'stopped') {
                serialConnected = false;
                statusIndicator.className = 'status-indicator status-offline';
                statusText.textContent = 'Disconnected';
                connectBtn.style.display = 'inline-block';
                disconnectBtn.style.display = 'none';
            } else if (data.status === 'error') {
                serialConnected = false;
                statusIndicator.className = 'status-indicator status-error';
                statusText.textContent = `Error: ${data.message}`;
                connectBtn.style.display = 'inline-block';
                disconnectBtn.style.display = 'none';
            }
        }


        // Logic Analyzer Functions
        function initializeLogicAnalyzer() {
            logicAnalyzerCanvas = document.getElementById('logicAnalyzerCanvas');
            logicAnalyzerCtx = logicAnalyzerCanvas.getContext('2d');

            // Set up controls - channel selection is dynamic
            document.getElementById('channelSelect').addEventListener('change', function() {
                logicChannelMode = this.value;
                // Update immediately without server call
                drawLogicAnalyzer();
            });

            document.getElementById('logicTimebaseInput').addEventListener('input', function() {
                logicTimebase = parseFloat(this.value);
                updateLogicAnalyzerConfig();
            });

            document.getElementById('logicAmplitudeInput').addEventListener('input', function() {
                logicAmplitudeScale = parseFloat(this.value);
                updateLogicAnalyzerConfig();
            });

            // Draw initial grid
            drawLogicAnalyzer();
        }

        function toggleLogicAnalyzer() {
            const btn = document.getElementById('logicAnalyzerBtn');
            const pauseBtn = document.getElementById('logicPauseBtn');
            if (logicAnalyzerActive) {
                // Stop logic analyzer
                logicAnalyzerActive = false;
                logicAnimationPaused = false;
                btn.textContent = 'Start Logic Analyzer';
                btn.classList.remove('active');
                pauseBtn.style.display = 'none';
                if (logicAnimationId) {
                    cancelAnimationFrame(logicAnimationId);
                    logicAnimationId = null;
                }
                // Stop acquisition on server
                fetch('/logic/stop', { method: 'POST' });
            } else {
                // Start logic analyzer
                logicAnalyzerActive = true;
                logicAnimationPaused = false;
                btn.textContent = 'Stop Logic Analyzer';
                btn.classList.add('active');
                pauseBtn.textContent = 'Pause';
                pauseBtn.style.display = 'inline-block';
                logicAnalyzerData = {
                    ch1_pos: [], ch1_neg: [], ch2_pos: [], ch2_neg: [],
                    ch1_logic: [], ch2_logic: [], timestamps: []
                };
                // Start acquisition on server
                fetch('/logic/start', { method: 'POST' })
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'error') {
                            alert('Error starting logic analyzer: ' + data.message);
                            toggleLogicAnalyzer(); // Stop if failed
                        } else {
                            startLogicAnalyzerAnimation();
                        }
                    })
                    .catch(error => {
                        console.error('Error starting logic analyzer:', error);
                        alert('Failed to start logic analyzer');
                        toggleLogicAnalyzer(); // Stop if failed
                    });
            }
        }

        function toggleLogicPause() {
            const pauseBtn = document.getElementById('logicPauseBtn');
            logicAnimationPaused = !logicAnimationPaused;
            pauseBtn.textContent = logicAnimationPaused ? 'Resume' : 'Pause';
            pauseBtn.classList.toggle('active', logicAnimationPaused);

            if (!logicAnimationPaused) {
                // Resume: draw immediately to show current data
                drawLogicAnalyzer();
            }
        }

        function startLogicAnalyzerAnimation() {
            function animate() {
                if (logicAnalyzerActive) {
                    drawLogicAnalyzer();
                    logicAnimationId = requestAnimationFrame(animate);
                }
            }
            animate();
        }

        function handleLogicAnalyzerData(data) {
            if (!logicAnalyzerActive) return;

            // Update data buffers with live streaming data
            if (data.ch1_data) {
                logicAnalyzerData.ch1_data = data.ch1_data;
            }
            if (data.ch2_data) {
                logicAnalyzerData.ch2_data = data.ch2_data;
            }
            if (data.timestamps) {
                logicAnalyzerData.timestamps = data.timestamps;
            }

            // Update frequency data
            if (data.ch1_frequency !== undefined) {
                logicAnalyzerData.ch1_frequency = data.ch1_frequency;
            }
            if (data.ch1_duty_cycle !== undefined) {
                logicAnalyzerData.ch1_duty_cycle = data.ch1_duty_cycle;
            }
            if (data.ch2_frequency !== undefined) {
                logicAnalyzerData.ch2_frequency = data.ch2_frequency;
            }
            if (data.ch2_duty_cycle !== undefined) {
                logicAnalyzerData.ch2_duty_cycle = data.ch2_duty_cycle;
            }

            // Update scaling parameters from server
            if (data.timebase !== undefined) {
                logicTimebase = data.timebase;
            }
            if (data.scale !== undefined) {
                logicAmplitudeScale = data.scale;
            }

            // Only draw if animation is not paused
            if (!logicAnimationPaused) {
                drawLogicAnalyzer();
            }
        }

        function drawLogicAnalyzer() {
            if (!logicAnalyzerCtx || !logicAnalyzerCanvas) return;

            const width = logicAnalyzerCanvas.width;
            const height = logicAnalyzerCanvas.height;
            const centerY = height / 2;

            // Clear canvas
            logicAnalyzerCtx.fillStyle = '#000';
            logicAnalyzerCtx.fillRect(0, 0, width, height);

            // Draw grid
            logicAnalyzerCtx.strokeStyle = '#333';
            logicAnalyzerCtx.lineWidth = 1;

            // Vertical grid lines
            for (let x = 0; x < width; x += width / 10) {
                logicAnalyzerCtx.beginPath();
                logicAnalyzerCtx.moveTo(x, 0);
                logicAnalyzerCtx.lineTo(x, height);
                logicAnalyzerCtx.stroke();
            }

            // Horizontal grid lines
            for (let y = 0; y < height; y += height / 8) {
                logicAnalyzerCtx.beginPath();
                logicAnalyzerCtx.moveTo(0, y);
                logicAnalyzerCtx.lineTo(width, y);
                logicAnalyzerCtx.stroke();
            }

            // Draw baselines - for differential logic analyzer, both channels share the same center line
            let centerBaselineY = height * 0.5;
            let ch1BaselineY, ch2BaselineY;

            if (logicChannelMode === 'both') {
                // Both channels use the same center line for phase comparison
                ch1BaselineY = centerBaselineY;
                ch2BaselineY = centerBaselineY;
            } else {
                // Single channel uses center line
                ch1BaselineY = centerBaselineY;
                ch2BaselineY = centerBaselineY;
            }

            logicAnalyzerCtx.strokeStyle = '#888';
            logicAnalyzerCtx.lineWidth = 2;

            // Draw center reference line when both channels are active
            if (logicChannelMode === 'both') {
                logicAnalyzerCtx.strokeStyle = '#666';
                logicAnalyzerCtx.setLineDash([5, 5]);
                logicAnalyzerCtx.beginPath();
                logicAnalyzerCtx.moveTo(0, centerBaselineY);
                logicAnalyzerCtx.lineTo(width, centerBaselineY);
                logicAnalyzerCtx.stroke();
                logicAnalyzerCtx.setLineDash([]); // Reset dash
            }

            // Draw individual channel baselines
            logicAnalyzerCtx.strokeStyle = '#888';
            if (logicChannelMode === 'ch1' || logicChannelMode === 'both') {
                logicAnalyzerCtx.beginPath();
                logicAnalyzerCtx.moveTo(0, ch1BaselineY);
                logicAnalyzerCtx.lineTo(width, ch1BaselineY);
                logicAnalyzerCtx.stroke();
            }

            if (logicChannelMode === 'ch2' || logicChannelMode === 'both') {
                logicAnalyzerCtx.beginPath();
                logicAnalyzerCtx.moveTo(0, ch2BaselineY);
                logicAnalyzerCtx.lineTo(width, ch2BaselineY);
                logicAnalyzerCtx.stroke();
            }

            // Channel labels and data
            logicAnalyzerCtx.fillStyle = '#fff';
            logicAnalyzerCtx.font = '12px monospace';

            // Draw channel data - simple 3-level plot (-1, 0, +1)
            if (logicChannelMode === 'ch1' || logicChannelMode === 'both') {
                if (logicAnalyzerData.ch1_data && logicAnalyzerData.ch1_data.length > 1) {
                    drawDifferentialChannel(logicAnalyzerData.ch1_data, logicAnalyzerData.timestamps, '#00ff00', ch1BaselineY, 'CH1');
                }
            }

            if (logicChannelMode === 'ch2' || logicChannelMode === 'both') {
                if (logicAnalyzerData.ch2_data && logicAnalyzerData.ch2_data.length > 1) {
                    drawDifferentialChannel(logicAnalyzerData.ch2_data, logicAnalyzerData.timestamps, '#0000ff', ch2BaselineY, 'CH2');
                }
            }

            // Draw info
            logicAnalyzerCtx.fillStyle = '#fff';
            logicAnalyzerCtx.font = '12px monospace';
            logicAnalyzerCtx.fillText(`Timebase: ${(logicTimebase * 1000).toFixed(1)}ms`, 10, height - 40);
            logicAnalyzerCtx.fillText(`Scale: ${logicAmplitudeScale.toFixed(1)}x`, 10, height - 20);
            logicAnalyzerCtx.fillText(`Mode: ${logicChannelMode}`, 10, height - 60);

            // Display frequency and duty cycle
            if (logicAnalyzerData.ch1_frequency && logicAnalyzerData.ch1_frequency > 0) {
                const freqText = logicAnalyzerData.ch1_frequency >= 1000 ?
                    `${(logicAnalyzerData.ch1_frequency/1000).toFixed(1)}kHz` :
                    `${logicAnalyzerData.ch1_frequency.toFixed(1)}Hz`;
                logicAnalyzerCtx.fillText(`CH1: ${freqText} ${logicAnalyzerData.ch1_duty_cycle?.toFixed(1) || 0}%`, 10, 20);
            }
            if (logicAnalyzerData.ch2_frequency && logicAnalyzerData.ch2_frequency > 0) {
                const freqText = logicAnalyzerData.ch2_frequency >= 1000 ?
                    `${(logicAnalyzerData.ch2_frequency/1000).toFixed(1)}kHz` :
                    `${logicAnalyzerData.ch2_frequency.toFixed(1)}Hz`;
                logicAnalyzerCtx.fillText(`CH2: ${freqText} ${logicAnalyzerData.ch2_duty_cycle?.toFixed(1) || 0}%`, 10, 40);
            }
        }

        function drawDifferentialChannel(data, timestamps, color, baselineY, label) {
            if (data.length < 2 || timestamps.length < 2) {
                return;
            }

            const width = logicAnalyzerCanvas.width;
            const height = logicAnalyzerCanvas.height;
            const timeSpan = timestamps[timestamps.length - 1] - timestamps[0];
            const pixelsPerSecond = width / (timeSpan * logicTimebase);

            // 3 horizontal lines: -1, 0, +1
            const plus1Y = baselineY - 40 * logicAmplitudeScale;  // +1 line
            const zeroY = baselineY;                              // 0 line (center)
            const minus1Y = baselineY + 40 * logicAmplitudeScale; // -1 line

            // Draw the 3 reference lines
            logicAnalyzerCtx.strokeStyle = '#666';
            logicAnalyzerCtx.lineWidth = 1;
            logicAnalyzerCtx.setLineDash([2, 2]);

            logicAnalyzerCtx.beginPath();
            logicAnalyzerCtx.moveTo(0, plus1Y);
            logicAnalyzerCtx.lineTo(width, plus1Y);
            logicAnalyzerCtx.stroke();

            logicAnalyzerCtx.beginPath();
            logicAnalyzerCtx.moveTo(0, zeroY);
            logicAnalyzerCtx.lineTo(width, zeroY);
            logicAnalyzerCtx.stroke();

            logicAnalyzerCtx.beginPath();
            logicAnalyzerCtx.moveTo(0, minus1Y);
            logicAnalyzerCtx.lineTo(width, minus1Y);
            logicAnalyzerCtx.stroke();

            logicAnalyzerCtx.setLineDash([]); // Reset dash

            // Label the lines
            logicAnalyzerCtx.fillStyle = '#888';
            logicAnalyzerCtx.font = '10px monospace';
            logicAnalyzerCtx.fillText('+1', 5, plus1Y - 2);
            logicAnalyzerCtx.fillText('0', 5, zeroY - 2);
            logicAnalyzerCtx.fillText('-1', 5, minus1Y - 2);

            // Plot the data as step function
            logicAnalyzerCtx.strokeStyle = color;
            logicAnalyzerCtx.lineWidth = 2;
            logicAnalyzerCtx.beginPath();

            let lastValue = data[0];
            let lastX = 0;
            let lastY = lastValue === 1 ? plus1Y : (lastValue === 0 ? zeroY : minus1Y);

            logicAnalyzerCtx.moveTo(lastX, lastY);

            // Step plot: horizontal lines with instant vertical transitions
            for (let i = 1; i < data.length; i++) {
                const currentValue = data[i];
                const currentTime = timestamps[i];
                const timeDiff = currentTime - timestamps[0];
                const x = timeDiff * pixelsPerSecond;

                // Stop if we exceed canvas width
                if (x > width) break;

                if (currentValue !== lastValue) {
                    // Draw horizontal line to transition point
                    logicAnalyzerCtx.lineTo(x, lastY);
                    // Instant vertical transition to new level
                    const newY = currentValue === 1 ? plus1Y : (currentValue === 0 ? zeroY : minus1Y);
                    logicAnalyzerCtx.lineTo(x, newY);
                    lastY = newY;
                } else {
                    // Continue horizontal line
                    logicAnalyzerCtx.lineTo(x, lastY);
                }

                lastValue = currentValue;
                lastX = x;
            }

            // Complete to end of canvas
            if (lastX < width) {
                logicAnalyzerCtx.lineTo(width, lastY);
            }

            logicAnalyzerCtx.stroke();

            // Draw channel label
            logicAnalyzerCtx.fillStyle = color;
            logicAnalyzerCtx.font = '12px monospace';
            const labelY = baselineY - 60;
            logicAnalyzerCtx.fillText(label, 10, labelY);
        }

        function drawEdgeMarkers(data, timestamps, color, pixelsPerSecond, highY, lowY) {
            if (data.length < 3) return;

            // Find edges in the displayed portion
            const markerSize = 4;
            logicAnalyzerCtx.fillStyle = color === '#00ff00' ? '#ffff00' : '#ff00ff'; // Yellow for CH1, Magenta for CH2

            for (let i = 1; i < Math.min(data.length, 1000); i++) { // Limit edge detection for performance
                const prevValue = data[i-1];
                const currValue = data[i];

                if (prevValue !== currValue) {
                    const edgeTime = timestamps[i];
                    const timeDiff = edgeTime - timestamps[0];
                    const x = timeDiff * pixelsPerSecond;

                    if (x >= 0 && x <= logicAnalyzerCanvas.width) {
                        // Draw edge marker - use proper thresholds for differential logic
                        let markerY;
                        if (currValue >= 0.8) { // High threshold
                            markerY = highY;
                        } else if (currValue <= 0.2) { // Low threshold
                            markerY = lowY;
                        } else { // Mid/off state
                            markerY = baselineY;
                        }
                        logicAnalyzerCtx.beginPath();
                        logicAnalyzerCtx.arc(x, markerY, markerSize, 0, 2 * Math.PI);
                        logicAnalyzerCtx.fill();

                        // Draw small indicator line
                        logicAnalyzerCtx.strokeStyle = color;
                        logicAnalyzerCtx.lineWidth = 1;
                        logicAnalyzerCtx.beginPath();
                        logicAnalyzerCtx.moveTo(x, highY - 10);
                        logicAnalyzerCtx.lineTo(x, lowY + 10);
                        logicAnalyzerCtx.stroke();
                    }
                }
            }
        }

        function clearLogicAnalyzer() {
            logicAnalyzerData = {
                ch1_data: [], ch2_data: [], timestamps: []
            };
            drawLogicAnalyzer();
        }

        function updateLogicAnalyzerConfig() {
            if (!logicAnalyzerActive) return;

            const config = {
                channel_mode: logicChannelMode,
                timebase: logicTimebase,
                amplitude_scale: logicAmplitudeScale
            };

            fetch('/logic/config', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(config)
            }).catch(error => {
                console.error('Error updating logic analyzer config:', error);
            });
        }



        // Audio Playback Functions - Optimized for independent operation
        // Server sends audio at 48kHz, client processes with Web Audio API
        let audioProcessor = null;
        let audioBuffer = null;
        let bufferWritePosition = 0;
        let bufferReadPosition = 0;
        const AUDIO_BUFFER_SIZE = 32768; // Larger buffer for better stability
        let audioDataQueue = [];
        let isProcessingAudio = false;
        let audioStartTime = 0;
        let expectedAudioChunks = 0;

        function hexToBytes(hex) {
            const bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i < bytes.length; i++) {
                bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
            }
            return bytes;
        }

        async function bufferAudioData(hexAudio) {
            if (!audioActive || !hexAudio) return;

            try {
                // Convert hex to bytes (efficient conversion)
                const bytes = hexToBytes(hexAudio);
                const pcmData = new Int16Array(bytes.buffer);

                // Add to processing queue with timestamp
                audioDataQueue.push({
                    data: pcmData,
                    timestamp: Date.now()
                });

                // Process queue if not already processing
                if (!isProcessingAudio) {
                    processAudioQueue();
                }
            } catch (error) {
                console.error('Error buffering audio data:', error);
            }
        }

        async function processAudioQueue() {
            if (isProcessingAudio || audioDataQueue.length === 0) return;

            isProcessingAudio = true;

            try {
                // Initialize buffer if needed
                if (!audioBuffer) {
                    audioBuffer = new Int16Array(AUDIO_BUFFER_SIZE);
                    bufferWritePosition = 0;
                    bufferReadPosition = 0;
                    audioStartTime = Date.now();
                    expectedAudioChunks = 0;
                }

                // Process queued audio data efficiently
                let processedChunks = 0;
                while (audioDataQueue.length > 0 && processedChunks < 5) { // Limit processing per cycle
                    const audioChunk = audioDataQueue.shift();
                    const pcmData = audioChunk.data;

                    // Add to circular buffer
                    for (let i = 0; i < pcmData.length; i++) {
                        audioBuffer[bufferWritePosition] = pcmData[i];
                        bufferWritePosition = (bufferWritePosition + 1) % AUDIO_BUFFER_SIZE;
                    }

                    processedChunks++;
                    expectedAudioChunks++;
                }

                // Initialize audio processor if not done and we have data
                if (!audioProcessor && expectedAudioChunks > 2) {
                    initializeAudioProcessor();
                }

            } catch (error) {
                console.error('Error processing audio queue:', error);
            }

            isProcessingAudio = false;
        }

        function initializeAudioProcessor() {
            if (audioProcessor) return; // Already initialized

            try {
                // Initialize audio context if not already done
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                // Resume audio context if suspended (required by some browsers)
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log('Audio context resumed');
                    });
                }

                // Create script processor with optimized buffer size
                const bufferSize = 2048; // Match server buffer size for sync
                audioProcessor = audioContext.createScriptProcessor(bufferSize, 1, 1);

                // Reset buffer positions for fresh start
                bufferWritePosition = 0;
                bufferReadPosition = 0;

                let consecutiveSilentBuffers = 0;
                const maxSilentBuffers = 50; // Allow more silence before giving up

                audioProcessor.onaudioprocess = function(audioProcessingEvent) {
                    const outputBuffer = audioProcessingEvent.outputBuffer;
                    const outputData = outputBuffer.getChannelData(0);

                    // Calculate available data in circular buffer
                    let availableData = bufferWritePosition - bufferReadPosition;
                    if (availableData < 0) {
                        availableData += AUDIO_BUFFER_SIZE;
                    }

                    if (availableData >= bufferSize) {
                        // Fill output buffer with audio data
                        for (let i = 0; i < bufferSize; i++) {
                            outputData[i] = audioBuffer[bufferReadPosition] / 32768.0; // Normalize to -1.0 to 1.0
                            bufferReadPosition = (bufferReadPosition + 1) % AUDIO_BUFFER_SIZE;
                        }
                        consecutiveSilentBuffers = 0; // Reset silence counter
                    } else {
                        // Not enough data - fill with silence
                        for (let i = 0; i < bufferSize; i++) {
                            outputData[i] = 0;
                        }
                        consecutiveSilentBuffers++;

                        // If too many silent buffers, we may have lost sync
                        if (consecutiveSilentBuffers > maxSilentBuffers) {
                            console.log('Audio buffer underrun - resetting');
                            bufferReadPosition = bufferWritePosition; // Reset to catch up
                            consecutiveSilentBuffers = 0;
                        }
                    }
                };

                audioProcessor.connect(audioContext.destination);
                console.log('Audio processor initialized successfully');

            } catch (error) {
                console.error('Error initializing audio processor:', error);
            }
        }

        function cleanupAudioProcessor() {
            if (audioProcessor) {
                try {
                    audioProcessor.disconnect();
                } catch (e) {
                    console.log('Error disconnecting audio processor:', e);
                }
                audioProcessor = null;
            }
            audioBuffer = null;
            audioDataQueue = [];
            bufferWritePosition = 0;
            bufferReadPosition = 0;
            isProcessingAudio = false;
            audioStartTime = 0;
            expectedAudioChunks = 0;
        }

        // Simplified audio data handler
        function handleAudioData(data) {
            if (audioActive) {
                bufferAudioData(data.audio);
            }
        }

        // Independent audio playback functions (removed as they're now handled by the processor)
        function startIndependentAudioPlayback() {
            // Audio processor handles playback independently now
            console.log('Audio processor handles independent playback');
        }

        function stopIndependentAudioPlayback() {
            // Cleanup handled by cleanupAudioProcessor
            console.log('Audio processor cleanup handled separately');
        }
    </script>
</body>
</html>
